# Common HTTP-level configuration
# Included in the http {} block of main nginx configs

# Define IP addresses exempt from rate limiting
# See https://blog.nginx.org/blog/rate-limiting-nginx
geo $ip_exempt {
    default 0;
    # 8.8.8.8 1;  # Exempt this IP from rate limiting
    # IP_EXEMPT_PLACEHOLDER
}

# Define hostnames exempt from rate limiting (optional)
map $host $host_exempt {
    default 0;
    # "internal.example.com" 1;  # Exempt this hostname from rate limiting
    # HOST_EXEMPT_PLACEHOLDER
}

# Combine IP and host exemptions: bypass rate limiting if EITHER is exempt
# Key is built as "$ip_exempt:$host_exempt" (e.g., "0:1", "1:0", "1:1")
# Only "0:0" (neither exempt) applies rate limiting; all other cases bypass
map "$ip_exempt:$host_exempt" $rate_limit_key {
    "0:0"   $binary_remote_addr;
    default "";
}

include /usr/local/openresty/nginx/conf/mime.types;
default_type application/json;

log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                '$status $body_bytes_sent "$http_referer" '
                '"$http_user_agent" "$http_x_forwarded_for" '
                'rt=$request_time backend=$upstream_addr';

access_log /var/log/nginx/access.log main;

sendfile on;
tcp_nopush on;
tcp_nodelay on;
keepalive_timeout 65;
keepalive_requests 1000;

# Shared memory for caching backend IPs
lua_shared_dict backend_cache 1m;

# Shared memory for rate limiting failed auth attempts
lua_shared_dict failed_auth_limit 10m;

# Initialize background refresh of backend IPs
init_worker_by_lua_block {
    local function refresh_backends()
        -- TODO: Query Postgres for current leader/follower IPs
        -- For now, use static values
        ngx.shared.backend_cache:set("leader", "{{ROLLUP_LEADER_IP}}:12346")
        ngx.shared.backend_cache:set("follower", "{{ROLLUP_FOLLOWER_IP}}:12346")

        -- Schedule next refresh
        local ok, err = ngx.timer.at(0.2, refresh_backends)
        if not ok then
            ngx.log(ngx.ERR, "failed to schedule backend refresh: ", err)
        end
    end

    -- Start the refresh timer
    ngx.timer.at(0, refresh_backends)
}

# Gzip compression
gzip on;
gzip_vary on;
gzip_min_length 1024;
gzip_types
    application/json
    text/plain
    text/css
    application/javascript
    text/xml
    application/xml
    application/xml+rss
    text/javascript;

# Buffer sizes - limit request body size
client_body_buffer_size 128k;    # Buffer small requests in memory
client_max_body_size 1m;         # Reject requests > 1MB
client_header_buffer_size 1k;
large_client_header_buffers 4 4k;

# DNS resolver for dynamic proxy_pass - AWS VPC DNS: https://docs.aws.amazon.com/vpc/latest/userguide/AmazonDNS-concepts.html
resolver 169.254.169.253 valid=10s;

# Proxy settings
proxy_buffering on;
proxy_buffer_size 64k;
proxy_buffers 8 64k;
proxy_busy_buffers_size 128k;
proxy_http_version 1.1;

# Rate limiting zone - 100 requests per second per IP
# Uses $rate_limit_key which is empty for exempted IPs or hostnames
limit_req_zone $rate_limit_key zone=global_limit:10m rate=100r/s;

# WebSocket connection upgrade map
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

# API key validation map
# Keys are validated by matching the path prefix /rpc/<key>
# Fille the placeholder with entries like:
#     ~^/rpc/abc123  1;
#     ~^/rpc/xyz789  1;
map $uri $valid_api_key {
    {{API_KEYS}}
    default 0;
}
